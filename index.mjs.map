{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2026 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isnanf from '@stdlib/math-base-assert-is-nanf';\nimport isInfinitef from '@stdlib/math-base-assert-is-infinitef';\nimport roundf from '@stdlib/math-base-special-roundf';\nimport powf from '@stdlib/math-base-special-powf';\nimport absf from '@stdlib/math-base-special-absf';\nimport f32 from '@stdlib/number-float64-base-to-float32';\nimport MAX_SAFE_INTEGER from '@stdlib/constants-float32-max-safe-integer';\nimport MAX_EXP from '@stdlib/constants-float32-max-base10-exponent';\nimport MIN_EXP from '@stdlib/constants-float32-min-base10-exponent';\nimport MIN_EXP_SUBNORMAL from '@stdlib/constants-float32-min-base10-exponent-subnormal';\n\n\n// VARIABLES //\n\nvar MAX_INT = MAX_SAFE_INTEGER + 1;\nvar HUGE = f32( 1.0e+38 );\n\n\n// MAIN //\n\n/**\n* Rounds a single-precision floating-point number to the nearest multiple of \\\\(10^n\\\\).\n*\n* ## Method\n*\n* 1.  If \\\\(|x| <= 2^{24}\\\\) and \\\\(|n| <= 38\\\\), we can use the formula\n*\n*     ```tex\n*     \\\\operatorname{roundnf}(x,n) = \\\\frac{\\\\operatorname{roundf}(x \\\\cdot 10^{-n})}{10^{-n}}\n*     ```\n*\n*     which shifts the decimal to the nearest multiple of \\\\(10^n\\\\), performs a standard \\\\(\\\\mathrm{roundf}\\\\) operation, and then shifts the decimal to its original position.\n*\n*     <!-- <note> -->\n*\n*     If \\\\(x \\\\cdot 10^{-n}\\\\) overflows, \\\\(x\\\\) lacks a sufficient number of decimal digits to have any effect when rounding. Accordingly, the rounded value is \\\\(x\\\\).\n*\n*     <!-- </note> -->\n*\n*     <!-- <note> -->\n*\n*     Note that rescaling \\\\(x\\\\) can result in unexpected behavior. For instance, the result of \\\\(\\\\operatorname{roundnf}(0.2+0.1,-16)\\\\) is \\\\(0.30000001192092896\\\\) and not \\\\(0.3\\\\). While possibly unexpected, this is not a bug. The behavior stems from the fact that most decimal fractions cannot be exactly represented as floating-point numbers. And further, rescaling can lead to slightly different fractional values, which, in turn, affects the result of \\\\(\\mathrm{roundf}\\\\).\n*\n*     <!-- </note> -->\n*\n* 2.  If \\\\(n > 38\\\\), we recognize that the maximum absolute single-precision floating-point number is \\\\(\\\\approx 3.4\\\\mbox{e}38\\\\) and, thus, the result of rounding any possible finite number \\\\(x\\\\) to the nearest \\\\(10^n\\\\) is \\\\(0.0\\\\). To ensure consistent behavior with \\\\(\\\\operatorname{roundf}(x)\\\\), the sign of \\\\(x\\\\) is preserved.\n*\n* 3.  If \\\\(n < -45\\\\), \\\\(n\\\\) exceeds the maximum number of possible decimal places (such as with subnormal numbers), and, thus, the rounded value is \\\\(x\\\\).\n*\n* 4.  If \\\\(x > 2^{24}\\\\), \\\\(x\\\\) is **always** an integer (i.e., \\\\(x\\\\) has no decimal digits). If \\\\(n <= 0\\\\), the rounded value is \\\\(x\\\\).\n*\n* 5.  If \\\\(n < -38\\\\), we let \\\\(m = n + 38\\\\) and modify the above formula to avoid overflow.\n*\n*     ```tex\n*     \\\\operatorname{roundnf}(x,n) = \\\\frac{\\\\biggl(\\\\frac{\\\\operatorname{roundf}( (x \\\\cdot 10^{38}) 10^{-m})}{10^{38}}\\\\biggr)}{10^{-m}}\n*     ```\n*\n*     If overflow occurs, the rounded value is \\\\(x\\\\).\n*\n* ## Special Cases\n*\n* ```tex\n* \\\\begin{align*}\n* \\\\operatorname{roundnf}(\\\\mathrm{NaN}, n) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(x, \\\\mathrm{NaN}) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(x, \\\\pm\\\\infty) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(\\\\pm\\\\infty, n) &= \\\\pm\\\\infty \\\\\\\\\n* \\\\operatorname{roundnf}(\\\\pm 0, n) &= \\\\pm 0\n* \\\\end{align*}\n* ```\n*\n* @param {number} x - input value\n* @param {integer} n - integer power of `10`\n* @returns {number} rounded value\n*\n* @example\n* // Round a value to 2 decimal places:\n* var v = roundnf( 3.1415927410125732, -2 );\n* // returns ~3.14\n*\n* @example\n* // If n = 0, `roundnf` behaves like `roundf`:\n* var v = roundnf( 3.1415927410125732, 0 );\n* // returns 3.0\n*\n* @example\n* // Round a value to the nearest thousand:\n* var v = roundnf( 12368.0, 3 );\n* // returns ~12000.0\n*/\nfunction roundnf( x, n ) {\n\tvar s;\n\tvar y;\n\n\tx = f32( x );\n\tif (\n\t\tisnanf( x ) ||\n\t\tisnanf( n ) ||\n\t\tisInfinitef( n )\n\t) {\n\t\treturn NaN;\n\t}\n\tif (\n\t\t// Handle infinities...\n\t\tisInfinitef( x ) ||\n\n\t\t// Handle +-0...\n\t\tx === 0.0 ||\n\n\t\t// If `n` exceeds the maximum number of feasible decimal places (such as with subnormal numbers), nothing to round...\n\t\tn < MIN_EXP_SUBNORMAL ||\n\n\t\t// If `|x|` is large enough, no decimals to round...\n\t\t( absf( x ) > MAX_INT && n <= 0 )\n\t) {\n\t\treturn x;\n\t}\n\t// The maximum absolute single-precision float is ~3.4e38. Accordingly, any possible finite `x` rounded to the nearest >=10^39 is 0.0.\n\tif ( n > MAX_EXP ) {\n\t\treturn f32( f32( 0.0 ) * x ); // preserve the sign (same behavior as roundf)\n\t}\n\t// If we overflow, return `x`, as the number of digits to the right of the decimal is too small (i.e., `x` is too large / lacks sufficient fractional precision) for there to be any effect when rounding...\n\tif ( n < MIN_EXP ) {\n\t\ts = powf( f32( 10.0 ), -( n + MAX_EXP ) );\n\t\ty = f32( f32( x * HUGE ) * s ); // order of operation matters!\n\t\tif ( isInfinitef( y ) ) {\n\t\t\treturn x;\n\t\t}\n\t\treturn f32( f32( roundf( y ) / HUGE ) / s );\n\t}\n\ts = powf( f32( 10.0 ), -n );\n\ty = f32( x * s );\n\tif ( isInfinitef( y ) ) {\n\t\treturn x;\n\t}\n\treturn f32( roundf( y ) / s );\n}\n\n\n// EXPORTS //\n\nexport default roundnf;\n"],"names":["MAX_INT","MAX_SAFE_INTEGER","HUGE","f32","roundnf","x","n","s","y","isnanf","isInfinitef","NaN","MIN_EXP_SUBNORMAL","absf","MAX_EXP","MIN_EXP","powf","roundf"],"mappings":";;6/BAoCA,IAAIA,EAAUC,EAAmB,EAC7BC,EAAOC,EAAK,MA2EhB,SAASC,EAASC,EAAGC,GACpB,IAAIC,EACAC,EAGJ,OADAH,EAAIF,EAAKE,GAERI,EAAQJ,IACRI,EAAQH,IACRI,EAAaJ,GAENK,IAIPD,EAAaL,IAGP,IAANA,GAGAC,EAAIM,GAGFC,EAAMR,GAAML,GAAWM,GAAK,EAEvBD,EAGHC,EAAIQ,EACDX,EAAKA,EAAK,GAAQE,GAGrBC,EAAIS,GACRR,EAAIS,EAAMb,EAAK,MAAWG,EAAIQ,IAC9BN,EAAIL,EAAKA,EAAKE,EAAIH,GAASK,GACtBG,EAAaF,GACVH,EAEDF,EAAKA,EAAKc,EAAQT,GAAMN,GAASK,KAEzCA,EAAIS,EAAMb,EAAK,KAASG,GACxBE,EAAIL,EAAKE,EAAIE,GACRG,EAAaF,GACVH,EAEDF,EAAKc,EAAQT,GAAMD,GAC3B"}