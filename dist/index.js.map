{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2026 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isnanf = require( '@stdlib/math-base-assert-is-nanf' );\nvar isInfinitef = require( '@stdlib/math-base-assert-is-infinitef' );\nvar roundf = require( '@stdlib/math-base-special-roundf' );\nvar powf = require( '@stdlib/math-base-special-powf' );\nvar absf = require( '@stdlib/math-base-special-absf' );\nvar f32 = require( '@stdlib/number-float64-base-to-float32' );\nvar MAX_SAFE_INTEGER = require( '@stdlib/constants-float32-max-safe-integer' );\nvar MAX_EXP = require( '@stdlib/constants-float32-max-base10-exponent' );\nvar MIN_EXP = require( '@stdlib/constants-float32-min-base10-exponent' );\nvar MIN_EXP_SUBNORMAL = require( '@stdlib/constants-float32-min-base10-exponent-subnormal' );\n\n\n// VARIABLES //\n\nvar MAX_INT = MAX_SAFE_INTEGER + 1;\nvar HUGE = f32( 1.0e+38 );\nvar ZERO = f32( 0.0 );\nvar TEN = f32( 10.0 );\n\n\n// MAIN //\n\n/**\n* Rounds a single-precision floating-point number to the nearest multiple of \\\\(10^n\\\\).\n*\n* ## Method\n*\n* 1.  If \\\\(|x| <= 2^{24}\\\\) and \\\\(|n| <= 38\\\\), we can use the formula\n*\n*     ```tex\n*     \\\\operatorname{roundnf}(x,n) = \\\\frac{\\\\operatorname{roundf}(x \\\\cdot 10^{-n})}{10^{-n}}\n*     ```\n*\n*     which shifts the decimal to the nearest multiple of \\\\(10^n\\\\), performs a standard \\\\(\\\\mathrm{roundf}\\\\) operation, and then shifts the decimal to its original position.\n*\n*     <!-- <note> -->\n*\n*     If \\\\(x \\\\cdot 10^{-n}\\\\) overflows, \\\\(x\\\\) lacks a sufficient number of decimal digits to have any effect when rounding. Accordingly, the rounded value is \\\\(x\\\\).\n*\n*     <!-- </note> -->\n*\n*     <!-- <note> -->\n*\n*     Note that rescaling \\\\(x\\\\) can result in unexpected behavior. For instance, the result of \\\\(\\\\operatorname{roundnf}(0.2+0.1,-7)\\\\) is \\\\(0.30000001192092896\\\\) and not \\\\(0.3\\\\). While possibly unexpected, this is not a bug. The behavior stems from the fact that most decimal fractions cannot be exactly represented as floating-point numbers. And further, rescaling can lead to slightly different fractional values, which, in turn, affects the result of \\\\(\\mathrm{roundf}\\\\).\n*\n*     <!-- </note> -->\n*\n* 2.  If \\\\(n > 38\\\\), we recognize that the maximum absolute single-precision floating-point number is \\\\(\\\\approx 3.4\\\\mbox{e}38\\\\) and, thus, the result of rounding any possible finite number \\\\(x\\\\) to the nearest \\\\(10^n\\\\) is \\\\(0.0\\\\). To ensure consistent behavior with \\\\(\\\\operatorname{roundf}(x)\\\\), the sign of \\\\(x\\\\) is preserved.\n*\n* 3.  If \\\\(n < -45\\\\), \\\\(n\\\\) exceeds the maximum number of possible decimal places (such as with subnormal numbers), and, thus, the rounded value is \\\\(x\\\\).\n*\n* 4.  If \\\\(x > 2^{24}\\\\), \\\\(x\\\\) is **always** an integer (i.e., \\\\(x\\\\) has no decimal digits). If \\\\(n <= 0\\\\), the rounded value is \\\\(x\\\\).\n*\n* 5.  If \\\\(n < -38\\\\), we let \\\\(m = n + 38\\\\) and modify the above formula to avoid overflow.\n*\n*     ```tex\n*     \\\\operatorname{roundnf}(x,n) = \\\\frac{\\\\biggl(\\\\frac{\\\\operatorname{roundf}( (x \\\\cdot 10^{38}) 10^{-m})}{10^{38}}\\\\biggr)}{10^{-m}}\n*     ```\n*\n*     If overflow occurs, the rounded value is \\\\(x\\\\).\n*\n* ## Special Cases\n*\n* ```tex\n* \\\\begin{align*}\n* \\\\operatorname{roundnf}(\\\\mathrm{NaN}, n) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(x, \\\\mathrm{NaN}) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(x, \\\\pm\\\\infty) &= \\\\mathrm{NaN} \\\\\\\\\n* \\\\operatorname{roundnf}(\\\\pm\\\\infty, n) &= \\\\pm\\\\infty \\\\\\\\\n* \\\\operatorname{roundnf}(\\\\pm 0, n) &= \\\\pm 0\n* \\\\end{align*}\n* ```\n*\n* @param {number} x - input value\n* @param {integer} n - integer power of `10`\n* @returns {number} rounded value\n*\n* @example\n* // Round a value to 2 decimal places:\n* var v = roundnf( 3.1415927410125732, -2 );\n* // returns ~3.14\n*\n* @example\n* // If n = 0, `roundnf` behaves like `roundf`:\n* var v = roundnf( 3.1415927410125732, 0 );\n* // returns 3.0\n*\n* @example\n* // Round a value to the nearest thousand:\n* var v = roundnf( 12368.0, 3 );\n* // returns ~12000.0\n*/\nfunction roundnf( x, n ) {\n\tvar s;\n\tvar y;\n\n\tx = f32( x );\n\tif (\n\t\tisnanf( x ) ||\n\t\tisnanf( n ) ||\n\t\tisInfinitef( n )\n\t) {\n\t\treturn NaN;\n\t}\n\tif (\n\t\t// Handle infinities...\n\t\tisInfinitef( x ) ||\n\n\t\t// Handle +-0...\n\t\tx === ZERO ||\n\n\t\t// If `n` exceeds the maximum number of feasible decimal places (such as with subnormal numbers), nothing to round...\n\t\tn < MIN_EXP_SUBNORMAL ||\n\n\t\t// If `|x|` is large enough, no decimals to round...\n\t\t( absf( x ) > MAX_INT && n <= 0 )\n\t) {\n\t\treturn x;\n\t}\n\t// The maximum absolute single-precision float is ~3.4e38. Accordingly, any possible finite `x` rounded to the nearest >=10^39 is 0.0.\n\tif ( n > MAX_EXP ) {\n\t\treturn f32( ZERO * x ); // preserve the sign (same behavior as roundf)\n\t}\n\t// If we overflow, return `x`, as the number of digits to the right of the decimal is too small (i.e., `x` is too large / lacks sufficient fractional precision) for there to be any effect when rounding...\n\tif ( n < MIN_EXP ) {\n\t\ts = powf( TEN, -( n + MAX_EXP ) );\n\t\ty = f32( f32( x * HUGE ) * s ); // order of operation matters!\n\t\tif ( isInfinitef( y ) ) {\n\t\t\treturn x;\n\t\t}\n\t\treturn f32( f32( roundf( y ) / HUGE ) / s );\n\t}\n\ts = powf( TEN, -n );\n\ty = f32( x * s );\n\tif ( isInfinitef( y ) ) {\n\t\treturn x;\n\t}\n\treturn f32( roundf( y ) / s );\n}\n\n\n// EXPORTS //\n\nmodule.exports = roundnf;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2026 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Round a single-precision floating-point number to the nearest multiple of `10^n`.\n*\n* @module @stdlib/math-base-special-roundnf\n*\n* @example\n* var roundnf = require( '@stdlib/math-base-special-roundnf' );\n*\n* // Round a value to 2 decimal places:\n* var v = roundnf( 3.1415927410125732, -2 );\n* // returns ~3.14\n*\n* // If n = 0, `roundnf` behaves like `roundf`:\n* var v = roundnf( 3.1415927410125732, 0 );\n* // returns 3.0\n*\n* // Round a value to the nearest thousand:\n* var v = roundnf( 12368.0, 3 );\n* // returns ~12000.0\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAS,QAAS,kCAAmC,EACrDC,EAAc,QAAS,uCAAwC,EAC/DC,EAAS,QAAS,kCAAmC,EACrDC,EAAO,QAAS,gCAAiC,EACjDC,EAAO,QAAS,gCAAiC,EACjDC,EAAM,QAAS,wCAAyC,EACxDC,EAAmB,QAAS,4CAA6C,EACzEC,EAAU,QAAS,+CAAgD,EACnEC,EAAU,QAAS,+CAAgD,EACnEC,EAAoB,QAAS,yDAA0D,EAKvFC,EAAUJ,EAAmB,EAC7BK,EAAON,EAAK,IAAQ,EACpBO,EAAOP,EAAK,CAAI,EAChBQ,EAAMR,EAAK,EAAK,EA2EpB,SAASS,EAASC,EAAGC,EAAI,CACxB,IAAIC,EACAC,EAGJ,OADAH,EAAIV,EAAKU,CAAE,EAEVf,EAAQe,CAAE,GACVf,EAAQgB,CAAE,GACVf,EAAae,CAAE,EAER,IAIPf,EAAac,CAAE,GAGfA,IAAMH,GAGNI,EAAIP,GAGFL,EAAMW,CAAE,EAAIL,GAAWM,GAAK,EAEvBD,EAGHC,EAAIT,EACDF,EAAKO,EAAOG,CAAE,EAGjBC,EAAIR,GACRS,EAAId,EAAMU,EAAK,EAAGG,EAAIT,EAAU,EAChCW,EAAIb,EAAKA,EAAKU,EAAIJ,CAAK,EAAIM,CAAE,EACxBhB,EAAaiB,CAAE,EACZH,EAEDV,EAAKA,EAAKH,EAAQgB,CAAE,EAAIP,CAAK,EAAIM,CAAE,IAE3CA,EAAId,EAAMU,EAAK,CAACG,CAAE,EAClBE,EAAIb,EAAKU,EAAIE,CAAE,EACVhB,EAAaiB,CAAE,EACZH,EAEDV,EAAKH,EAAQgB,CAAE,EAAID,CAAE,EAC7B,CAKAlB,EAAO,QAAUe,IC1HjB,IAAIK,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "isnanf", "isInfinitef", "roundf", "powf", "absf", "f32", "MAX_SAFE_INTEGER", "MAX_EXP", "MIN_EXP", "MIN_EXP_SUBNORMAL", "MAX_INT", "HUGE", "ZERO", "TEN", "roundnf", "x", "n", "s", "y", "main"]
}
